"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const assert_1 = __importDefault(require("assert"));
const inversify_1 = require("inversify");
const supertest_1 = __importDefault(require("supertest"));
const base_middleware_1 = require("../../base_middleware");
const constants_1 = require("../../constants");
const decorators_1 = require("../../decorators");
const server_1 = require("../../server");
const utils_1 = require("../../utils");
function cleanUpMidDecTestControllerMetadata() {
    class MidDecTestController {
    }
    Reflect.defineMetadata(constants_1.METADATA_KEY.middleware, {}, MidDecTestController.constructor);
}
(0, globals_1.describe)('Unit Test: @middleware decorator', () => {
    (0, globals_1.beforeEach)(() => {
        (0, utils_1.cleanUpMetadata)();
        cleanUpMidDecTestControllerMetadata();
    });
    (0, globals_1.it)('should add method metadata to a class when a handler is decorated with @withMiddleware', () => {
        const functionMiddleware = () => undefined;
        const identifierMiddleware = Symbol.for('foo');
        const path = 'foo';
        const method = constants_1.HTTP_VERBS_ENUM.get;
        class MidDecTestController {
            test() {
                // do nothing
            }
            test2() {
                // do nothing
            }
        }
        __decorate([
            (0, decorators_1.httpMethod)(method, path),
            (0, decorators_1.withMiddleware)(functionMiddleware),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], MidDecTestController.prototype, "test", null);
        __decorate([
            (0, decorators_1.httpMethod)(method, path),
            (0, decorators_1.withMiddleware)(functionMiddleware, identifierMiddleware),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], MidDecTestController.prototype, "test2", null);
        const methodMetadata = Reflect.getMetadata(constants_1.METADATA_KEY.controllerMethod, MidDecTestController);
        const [testMetaData, test2MetaData] = methodMetadata;
        assert_1.default.strictEqual(testMetaData?.middleware.length, 1);
        assert_1.default.strictEqual(test2MetaData?.middleware.length, 2);
        assert_1.default.deepStrictEqual(testMetaData.middleware, [functionMiddleware]);
        assert_1.default.deepStrictEqual(test2MetaData.middleware, [
            functionMiddleware,
            identifierMiddleware,
        ]);
    });
    (0, globals_1.it)('should add class metadata to a controller class when decorated with @withMiddleware', () => {
        const identifierMiddleware = Symbol.for('foo');
        const functionMiddleware = () => undefined;
        let MidDecTestController = class MidDecTestController {
        };
        MidDecTestController = __decorate([
            (0, decorators_1.controller)('/foo'),
            (0, decorators_1.withMiddleware)(identifierMiddleware, functionMiddleware)
        ], MidDecTestController);
        const controllerMetaData = Reflect.getMetadata(constants_1.METADATA_KEY.controller, MidDecTestController);
        assert_1.default.strictEqual(controllerMetaData.middleware.length, 2);
        assert_1.default.deepStrictEqual(controllerMetaData.middleware, [
            identifierMiddleware,
            functionMiddleware,
        ]);
    });
    (0, globals_1.it)('should be able to add middleware from multiple decorations', () => {
        const identifierMiddleware = Symbol.for('foo');
        const functionMiddleware = () => undefined;
        const first = (0, decorators_1.withMiddleware)(identifierMiddleware);
        const second = (0, decorators_1.withMiddleware)(functionMiddleware);
        let MidDecTestController = class MidDecTestController {
        };
        MidDecTestController = __decorate([
            (0, decorators_1.controller)('/foo'),
            first,
            second
        ], MidDecTestController);
        const controllerMetaData = Reflect.getMetadata(constants_1.METADATA_KEY.controller, MidDecTestController);
        assert_1.default.strictEqual(controllerMetaData.middleware.length, 2);
        assert_1.default.deepStrictEqual(controllerMetaData.middleware, [
            functionMiddleware,
            identifierMiddleware,
        ]);
    });
    (0, globals_1.it)('should process all requests when decorating a controller', async () => {
        const addTestHeader = (0, decorators_1.withMiddleware)((_req, res, next) => {
            res.set('test-header', 'foo');
            next();
        });
        let MidDecTestController = class MidDecTestController {
            get() {
                return { data: 'hello' };
            }
            put() {
                return { data: 'there' };
            }
        };
        __decorate([
            (0, decorators_1.httpGet)('/bar'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], MidDecTestController.prototype, "get", null);
        __decorate([
            (0, decorators_1.httpPut)('/baz'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], MidDecTestController.prototype, "put", null);
        MidDecTestController = __decorate([
            (0, decorators_1.controller)('/foo'),
            addTestHeader
        ], MidDecTestController);
        const container = new inversify_1.Container();
        container
            .bind('MidDecTestController')
            .to(MidDecTestController);
        const server = new server_1.InversifyExpressServer(container);
        const app = server.build();
        const barResponse = await (0, supertest_1.default)(app).get('/foo/bar');
        const bazResponse = await (0, supertest_1.default)(app).put('/foo/baz');
        assert_1.default.strictEqual(barResponse.header['test-header'], 'foo');
        assert_1.default.strictEqual(bazResponse.header['test-header'], 'foo');
    });
    (0, globals_1.it)('should process only specific requests when decorating a handler', async () => {
        const addTestHeader = (0, decorators_1.withMiddleware)((_req, res, next) => {
            res.set('test-header', 'foo');
            next();
        });
        let MidDecTestController = class MidDecTestController {
            get() {
                return { data: 'hello' };
            }
            put() {
                return { data: 'there' };
            }
        };
        __decorate([
            (0, decorators_1.httpGet)('/bar'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], MidDecTestController.prototype, "get", null);
        __decorate([
            (0, decorators_1.httpPut)('/baz'),
            addTestHeader,
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], MidDecTestController.prototype, "put", null);
        MidDecTestController = __decorate([
            (0, decorators_1.controller)('/foo')
        ], MidDecTestController);
        const container = new inversify_1.Container();
        container
            .bind('MidDecTestController')
            .to(MidDecTestController);
        const server = new server_1.InversifyExpressServer(container);
        const app = server.build();
        const barResponse = await (0, supertest_1.default)(app).get('/foo/bar');
        const bazResponse = await (0, supertest_1.default)(app).put('/foo/baz');
        assert_1.default.strictEqual(barResponse.header['test-header'], undefined);
        assert_1.default.strictEqual(bazResponse.header['test-header'], 'foo');
    });
    (0, globals_1.it)('should process requests with both controller- and handler middleware', async () => {
        const addHandlerHeader = (0, decorators_1.withMiddleware)((_req, res, next) => {
            res.set('test-handler', 'hello there!');
            next();
        });
        const addControllerHeader = (0, decorators_1.withMiddleware)((_req, res, next) => {
            res.set('test-controller', 'general kenobi');
            next();
        });
        let MidDecTestController = class MidDecTestController {
            get() {
                return { data: 'hello' };
            }
            put() {
                return { data: 'there' };
            }
        };
        __decorate([
            (0, decorators_1.httpGet)('/bar'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], MidDecTestController.prototype, "get", null);
        __decorate([
            (0, decorators_1.httpPut)('/baz'),
            addHandlerHeader,
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], MidDecTestController.prototype, "put", null);
        MidDecTestController = __decorate([
            (0, decorators_1.controller)('/foo'),
            addControllerHeader
        ], MidDecTestController);
        const container = new inversify_1.Container();
        container
            .bind('MidDecTestController')
            .to(MidDecTestController);
        const server = new server_1.InversifyExpressServer(container);
        const app = server.build();
        const barResponse = await (0, supertest_1.default)(app).get('/foo/bar');
        assert_1.default.strictEqual(barResponse.header['test-controller'], 'general kenobi');
        assert_1.default.strictEqual(barResponse.header['test-handler'], undefined);
        const bazResponse = await (0, supertest_1.default)(app).put('/foo/baz');
        assert_1.default.strictEqual(bazResponse.header['test-controller'], 'general kenobi');
        assert_1.default.strictEqual(bazResponse.header['test-handler'], 'hello there!');
    });
    (0, globals_1.it)('should be able to inject BaseMiddleware services by identifier', async () => {
        const container = new inversify_1.Container();
        class MidDecTestMiddleware extends base_middleware_1.BaseMiddleware {
            handler(_req, res, next) {
                res.set('test-base-middleware', 'working');
                next();
            }
        }
        container
            .bind('TestMiddleware')
            .to(MidDecTestMiddleware);
        let MidDecTestController = class MidDecTestController {
            get() {
                return { data: 'hello' };
            }
        };
        __decorate([
            (0, decorators_1.httpGet)('/bar'),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], MidDecTestController.prototype, "get", null);
        MidDecTestController = __decorate([
            (0, decorators_1.controller)('/foo'),
            (0, decorators_1.withMiddleware)('TestMiddleware')
        ], MidDecTestController);
        container
            .bind('MidDecTestController')
            .to(MidDecTestController);
        const server = new server_1.InversifyExpressServer(container);
        const app = server.build();
        const response = await (0, supertest_1.default)(app).get('/foo/bar');
        assert_1.default.strictEqual(response.header['test-base-middleware'], 'working');
    });
});
//# sourceMappingURL=decorator_middleware.test.js.map