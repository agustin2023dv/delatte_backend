"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-unused-vars */
const globals_1 = require("@jest/globals");
const cookie_parser_1 = __importDefault(require("cookie-parser"));
const express_1 = require("express");
const inversify_1 = require("inversify");
const supertest_1 = __importDefault(require("supertest"));
const decorators_1 = require("../decorators");
const server_1 = require("../server");
const utils_1 = require("../utils");
(0, globals_1.describe)('Integration Tests:', () => {
    let server;
    let container;
    (0, globals_1.beforeEach)(() => {
        (0, utils_1.cleanUpMetadata)();
        container = new inversify_1.Container();
    });
    (0, globals_1.describe)('Routing & Request Handling:', () => {
        (0, globals_1.it)('should work for async controller methods', async () => {
            let TestController = class TestController {
                async getTest(req, res) {
                    return new Promise((resolve) => {
                        setTimeout(() => {
                            resolve('GET');
                        }, 10);
                    });
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", Promise)
            ], TestController.prototype, "getTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            await (0, supertest_1.default)(server.build()).get('/').expect(200, 'GET');
        });
        (0, globals_1.it)('should work for async controller methods that fails', async () => {
            let TestController = class TestController {
                async getTest(req, res) {
                    return new Promise((_resolve, reject) => {
                        setTimeout(() => {
                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
                            reject('GET');
                        }, 10);
                    });
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", Promise)
            ], TestController.prototype, "getTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            await (0, supertest_1.default)(server.build()).get('/').expect(500);
        });
        (0, globals_1.it)('should work for methods which call nextFunc()', async () => {
            let TestController = class TestController {
                getTest(req, res, nextFunc) {
                    nextFunc();
                }
                getTest2(req, res) {
                    return 'GET';
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object, Function]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest2", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            await (0, supertest_1.default)(server.build()).get('/').expect(200, 'GET');
        });
        (0, globals_1.it)('should work for async methods which call nextFunc()', async () => {
            let TestController = class TestController {
                async getTest(_req, _res, nextFunc) {
                    return new Promise((resolve) => {
                        setTimeout(() => {
                            nextFunc();
                            resolve(null);
                        }, 10);
                    });
                }
                getTest2(req, res) {
                    return 'GET';
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object, Function]),
                __metadata("design:returntype", Promise)
            ], TestController.prototype, "getTest", null);
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest2", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            await (0, supertest_1.default)(server.build()).get('/').expect(200, 'GET');
        });
        (0, globals_1.it)('should work for async methods called by nextFunc()', async () => {
            let TestController = class TestController {
                getTest(req, res, nextFunc) {
                    return nextFunc;
                }
                async getTest2(req, res) {
                    return new Promise((resolve) => {
                        setTimeout(() => {
                            resolve('GET');
                        }, 10);
                    });
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object, Function]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", Promise)
            ], TestController.prototype, "getTest2", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            await (0, supertest_1.default)(server.build()).get('/').expect(200, 'GET');
        });
        (0, globals_1.it)('should work for each shortcut decorator', async () => {
            let TestController = class TestController {
                getTest(_req, res) {
                    res.send('GET');
                }
                postTest(_req, res) {
                    res.send('POST');
                }
                putTest(_req, res) {
                    res.send('PUT');
                }
                patchTest(_req, res) {
                    res.send('PATCH');
                }
                headTest(_req, res) {
                    res.send('HEAD');
                }
                deleteTest(_req, res) {
                    res.send('DELETE');
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            __decorate([
                (0, decorators_1.httpPost)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "postTest", null);
            __decorate([
                (0, decorators_1.httpPut)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "putTest", null);
            __decorate([
                (0, decorators_1.httpPatch)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "patchTest", null);
            __decorate([
                (0, decorators_1.httpHead)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "headTest", null);
            __decorate([
                (0, decorators_1.httpDelete)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "deleteTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            const agent = (0, supertest_1.default)(server.build());
            await agent.get('/').expect(200, 'GET');
            await agent.post('/').expect(200, 'POST');
            await agent.put('/').expect(200, 'PUT');
            await agent.patch('/').expect(200, 'PATCH');
            await agent.head('/').expect(200, undefined); // HEAD requests have no body
            await agent.delete('/').expect(200, 'DELETE');
        });
        (0, globals_1.it)('should work for more obscure HTTP methods using the httpMethod decorator', async () => {
            let TestController = class TestController {
                getTest(req, res) {
                    res.send('PROPFIND');
                }
            };
            __decorate([
                (0, decorators_1.httpMethod)('propfind', '/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            await (0, supertest_1.default)(server.build()).propfind('/').expect(200, 'PROPFIND');
        });
        (0, globals_1.it)('should use returned values as response', async () => {
            const result = { hello: 'world' };
            let TestController = class TestController {
                getTest(req, res) {
                    return result;
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            await (0, supertest_1.default)(server.build())
                .get('/')
                .expect(200, JSON.stringify(result));
        });
        (0, globals_1.it)('should use custom router passed from configuration', async () => {
            let TestController = class TestController {
                get() {
                    return 'Such Text';
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/Endpoint'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", []),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "get", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/CaseSensitive')
            ], TestController);
            const customRouter = (0, express_1.Router)({
                caseSensitive: true,
            });
            server = new server_1.InversifyExpressServer(container, customRouter);
            const app = server.build();
            const expectedSuccess = (0, supertest_1.default)(app)
                .get('/CaseSensitive/Endpoint')
                .expect(200, 'Such Text');
            const expectedNotFound1 = (0, supertest_1.default)(app)
                .get('/casesensitive/endpoint')
                .expect(404);
            const expectedNotFound2 = (0, supertest_1.default)(app)
                .get('/CaseSensitive/endpoint')
                .expect(404);
            return Promise.all([
                expectedSuccess,
                expectedNotFound1,
                expectedNotFound2,
            ]);
        });
        (0, globals_1.it)('should use custom routing configuration', () => {
            let TestController = class TestController {
                get() {
                    return 'pong';
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/endpoint'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", []),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "get", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/ping')
            ], TestController);
            server = new server_1.InversifyExpressServer(container, null, {
                rootPath: '/api/v1',
            });
            return (0, supertest_1.default)(server.build())
                .get('/api/v1/ping/endpoint')
                .expect(200, 'pong');
        });
        (0, globals_1.it)("should work for controller methods who's return value is falsey", async () => {
            let TestController = class TestController {
                async delete() {
                    return undefined;
                }
            };
            __decorate([
                (0, decorators_1.httpDelete)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", []),
                __metadata("design:returntype", Promise)
            ], TestController.prototype, "delete", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/user')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            try {
                await (0, supertest_1.default)(server.build())
                    .delete('/user')
                    .timeout({ deadline: 200, response: 100 });
                throw new Error('Expected request to hang, but a response was received');
            }
            catch (error) {
                if (!('timeout' in error)) {
                    throw error;
                }
            }
        });
    });
    (0, globals_1.describe)('Middleware:', () => {
        let result;
        const middleware = {
            a(req, res, nextFunc) {
                result += 'a';
                nextFunc();
            },
            b(req, res, nextFunc) {
                result += 'b';
                nextFunc();
            },
            c(req, res, nextFunc) {
                result += 'c';
                nextFunc();
            },
        };
        const spyA = globals_1.jest
            .fn()
            .mockImplementation(middleware.a.bind(middleware));
        const spyB = globals_1.jest
            .fn()
            .mockImplementation(middleware.b.bind(middleware));
        const spyC = globals_1.jest
            .fn()
            .mockImplementation(middleware.c.bind(middleware));
        (0, globals_1.beforeEach)(() => {
            spyA.mockClear();
            spyB.mockClear();
            spyC.mockClear();
            result = '';
        });
        (0, globals_1.it)('should call method-level middleware correctly (GET)', async () => {
            let TestController = class TestController {
                getTest(req, res) {
                    res.send('GET');
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/', spyA, spyB, spyC),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            const agent = (0, supertest_1.default)(server.build());
            await agent.get('/').expect(200, 'GET');
            (0, globals_1.expect)(spyA).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyB).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyC).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(result).toBe('abc');
        });
        (0, globals_1.it)('should call method-level middleware correctly (POST)', async () => {
            let TestController = class TestController {
                postTest(req, res) {
                    res.send('POST');
                }
            };
            __decorate([
                (0, decorators_1.httpPost)('/', spyA, spyB, spyC),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "postTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            const agent = (0, supertest_1.default)(server.build());
            await agent.post('/').expect(200, 'POST');
            (0, globals_1.expect)(spyA).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyB).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyC).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(result).toBe('abc');
        });
        (0, globals_1.it)('should call method-level middleware correctly (PUT)', async () => {
            let TestController = class TestController {
                postTest(req, res) {
                    res.send('PUT');
                }
            };
            __decorate([
                (0, decorators_1.httpPut)('/', spyA, spyB, spyC),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "postTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            const agent = (0, supertest_1.default)(server.build());
            await agent.put('/').expect(200, 'PUT');
            (0, globals_1.expect)(spyA).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyB).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyC).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(result).toBe('abc');
        });
        (0, globals_1.it)('should call method-level middleware correctly (PATCH)', async () => {
            let TestController = class TestController {
                postTest(req, res) {
                    res.send('PATCH');
                }
            };
            __decorate([
                (0, decorators_1.httpPatch)('/', spyA, spyB, spyC),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "postTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            const agent = (0, supertest_1.default)(server.build());
            await agent.patch('/').expect(200, 'PATCH');
            (0, globals_1.expect)(spyA).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyB).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyC).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(result).toBe('abc');
        });
        (0, globals_1.it)('should call method-level middleware correctly (HEAD)', async () => {
            let TestController = class TestController {
                postTest(req, res) {
                    res.send('HEAD');
                }
            };
            __decorate([
                (0, decorators_1.httpHead)('/', spyA, spyB, spyC),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "postTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            const agent = (0, supertest_1.default)(server.build());
            await agent.head('/').expect(200, undefined); // HEAD requests have no body
            (0, globals_1.expect)(spyA).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyB).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyC).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(result).toBe('abc');
        });
        (0, globals_1.it)('should call method-level middleware correctly (DELETE)', async () => {
            let TestController = class TestController {
                postTest(req, res) {
                    res.send('DELETE');
                }
            };
            __decorate([
                (0, decorators_1.httpDelete)('/', spyA, spyB, spyC),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "postTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            const agent = (0, supertest_1.default)(server.build());
            await agent.delete('/').expect(200, 'DELETE');
            (0, globals_1.expect)(spyA).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyB).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyC).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(result).toBe('abc');
        });
        (0, globals_1.it)('should call method-level middleware correctly (ALL)', async () => {
            let TestController = class TestController {
                postTest(req, res) {
                    res.send('ALL');
                }
            };
            __decorate([
                (0, decorators_1.all)('/', spyA, spyB, spyC),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "postTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            const agent = (0, supertest_1.default)(server.build());
            await agent.get('/').expect(200, 'ALL');
            (0, globals_1.expect)(spyA).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyB).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyC).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(result).toBe('abc');
        });
        (0, globals_1.it)('should call controller-level middleware correctly', async () => {
            let TestController = class TestController {
                getTest(req, res) {
                    res.send('GET');
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/', spyA, spyB, spyC)
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            await (0, supertest_1.default)(server.build()).get('/').expect(200, 'GET');
            (0, globals_1.expect)(spyA).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyB).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyC).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(result).toBe('abc');
        });
        (0, globals_1.it)('should call server-level middleware correctly', async () => {
            let TestController = class TestController {
                getTest(req, res) {
                    res.send('GET');
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            server.setConfig((app) => {
                app.use(spyA);
                app.use(spyB);
                app.use(spyC);
            });
            await (0, supertest_1.default)(server.build()).get('/').expect(200, 'GET');
            (0, globals_1.expect)(spyA).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyB).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyC).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(result).toBe('abc');
        });
        (0, globals_1.it)('should call all middleware in correct order', async () => {
            let TestController = class TestController {
                getTest(req, res) {
                    res.send('GET');
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/', spyC),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/', spyB)
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            server.setConfig((app) => {
                app.use(spyA);
            });
            await (0, supertest_1.default)(server.build()).get('/').expect(200, 'GET');
            (0, globals_1.expect)(spyA).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyB).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyC).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(result).toBe('abc');
        });
        (0, globals_1.it)('should resolve controller-level middleware', async () => {
            const symbolId = Symbol.for('spyA');
            const strId = 'spyB';
            let TestController = class TestController {
                getTest(req, res) {
                    res.send('GET');
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/', symbolId, strId)
            ], TestController);
            container.bind(symbolId).toConstantValue(spyA);
            container.bind(strId).toConstantValue(spyB);
            server = new server_1.InversifyExpressServer(container);
            const agent = (0, supertest_1.default)(server.build());
            await agent.get('/').expect(200, 'GET');
            (0, globals_1.expect)(spyA).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyB).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(result).toBe('ab');
        });
        (0, globals_1.it)('should resolve method-level middleware', async () => {
            const symbolId = Symbol.for('spyA');
            const strId = 'spyB';
            let TestController = class TestController {
                getTest(req, res) {
                    res.send('GET');
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/', symbolId, strId),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            container.bind(symbolId).toConstantValue(spyA);
            container.bind(strId).toConstantValue(spyB);
            server = new server_1.InversifyExpressServer(container);
            const agent = (0, supertest_1.default)(server.build());
            await agent.get('/').expect(200, 'GET');
            (0, globals_1.expect)(spyA).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyB).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(result).toBe('ab');
        });
        (0, globals_1.it)('should compose controller- and method-level middleware', async () => {
            const symbolId = Symbol.for('spyA');
            const strId = 'spyB';
            let TestController = class TestController {
                getTest(req, res) {
                    res.send('GET');
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/', strId),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/', symbolId)
            ], TestController);
            container.bind(symbolId).toConstantValue(spyA);
            container.bind(strId).toConstantValue(spyB);
            server = new server_1.InversifyExpressServer(container);
            const agent = (0, supertest_1.default)(server.build());
            await agent.get('/').expect(200, 'GET');
            (0, globals_1.expect)(spyA).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(spyB).toHaveBeenCalledTimes(1);
            (0, globals_1.expect)(result).toBe('ab');
        });
    });
    (0, globals_1.describe)('Parameters:', () => {
        (0, globals_1.it)('should bind a method parameter to the url parameter of the web request', async () => {
            let TestController = class TestController {
                getTest(id, req, res) {
                    return id;
                }
            };
            __decorate([
                (0, decorators_1.httpGet)(':id'),
                __param(0, (0, decorators_1.requestParam)('id')),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [String, Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            await (0, supertest_1.default)(server.build()).get('/foo').expect(200, 'foo');
        });
        (0, globals_1.it)('should bind a method parameter to the request object', async () => {
            let TestController = class TestController {
                getTest(req) {
                    return req.params['id'];
                }
            };
            __decorate([
                (0, decorators_1.httpGet)(':id'),
                __param(0, (0, decorators_1.request)()),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            await (0, supertest_1.default)(server.build()).get('/GET').expect(200, 'GET');
        });
        (0, globals_1.it)('should bind a method parameter to the response object', async () => {
            let TestController = class TestController {
                getTest(res) {
                    return res.send('foo');
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __param(0, (0, decorators_1.response)()),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            await (0, supertest_1.default)(server.build()).get('/').expect(200, 'foo');
        });
        (0, globals_1.it)('should bind a method parameter to a query parameter', async () => {
            let TestController = class TestController {
                getTest(id) {
                    return id;
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __param(0, (0, decorators_1.queryParam)('id')),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [String]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            await (0, supertest_1.default)(server.build())
                .get('/')
                .query('id=foo')
                .expect(200, 'foo');
        });
        (0, globals_1.it)('should bind a method parameter to the request body', async () => {
            let TestController = class TestController {
                getTest(reqBody) {
                    return reqBody;
                }
            };
            __decorate([
                (0, decorators_1.httpPost)('/'),
                __param(0, (0, decorators_1.requestBody)()),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [String]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            const body = { foo: 'bar' };
            server.setConfig((app) => {
                app.use((0, express_1.json)());
            });
            await (0, supertest_1.default)(server.build()).post('/').send(body).expect(200, body);
        });
        (0, globals_1.it)('should bind a method parameter to the request headers', async () => {
            let TestController = class TestController {
                getTest(headers) {
                    return headers;
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __param(0, (0, decorators_1.requestHeaders)('testhead')),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            await (0, supertest_1.default)(server.build())
                .get('/')
                .set('TestHead', 'foo')
                .expect(200, 'foo');
        });
        (0, globals_1.it)('should be case insensitive to request headers', async () => {
            let TestController = class TestController {
                getTest(headers) {
                    return headers;
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __param(0, (0, decorators_1.requestHeaders)('TestHead')),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            await (0, supertest_1.default)(server.build())
                .get('/')
                .set('TestHead', 'foo')
                .expect(200, 'foo');
        });
        (0, globals_1.it)('should bind a method parameter to a cookie', async () => {
            let TestController = class TestController {
                getCookie(cookie, req, res) {
                    return cookie;
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __param(0, (0, decorators_1.cookies)('Cookie')),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object, Object, Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getCookie", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            server.setConfig((app) => {
                app.use((0, cookie_parser_1.default)());
            });
            await (0, supertest_1.default)(server.build())
                .get('/')
                .set('Cookie', 'Cookie=hey')
                .expect(200, 'hey');
        });
        (0, globals_1.it)('should bind a method parameter to the next function', async () => {
            let TestController = class TestController {
                getTest(nextFunc) {
                    return nextFunc();
                }
                getResult() {
                    return 'foo';
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __param(0, (0, decorators_1.next)()),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Function]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getTest", null);
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", []),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getResult", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            await (0, supertest_1.default)(server.build()).get('/').expect(200, 'foo');
        });
        (0, globals_1.it)('should bind a method parameter to a principal with null (empty) details when no AuthProvider is set.', async () => {
            let TestController = class TestController {
                getPrincipalTest(userPrincipal) {
                    return userPrincipal.details;
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __param(0, (0, decorators_1.principal)()),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getPrincipalTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            server = new server_1.InversifyExpressServer(container);
            await (0, supertest_1.default)(server.build()).get('/').expect(200, '');
        });
        (0, globals_1.it)('should bind a method parameter to a principal with valid details when an AuthProvider is set.', async () => {
            let TestController = class TestController {
                getPrincipalTest(userPrincipal) {
                    return userPrincipal.details;
                }
            };
            __decorate([
                (0, decorators_1.httpGet)('/'),
                __param(0, (0, decorators_1.principal)()),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object]),
                __metadata("design:returntype", void 0)
            ], TestController.prototype, "getPrincipalTest", null);
            TestController = __decorate([
                (0, decorators_1.controller)('/')
            ], TestController);
            let CustomAuthProvider = class CustomAuthProvider {
                async getUser(req, res, nextFunc) {
                    return Promise.resolve({
                        details: 'something',
                        isAuthenticated: async () => Promise.resolve(true),
                        isInRole: async () => Promise.resolve(true),
                        isResourceOwner: async () => Promise.resolve(true),
                    });
                }
            };
            CustomAuthProvider = __decorate([
                (0, inversify_1.injectable)()
            ], CustomAuthProvider);
            server = new server_1.InversifyExpressServer(container, null, null, null, CustomAuthProvider);
            await (0, supertest_1.default)(server.build()).get('/').expect(200, 'something');
        });
    });
});
//# sourceMappingURL=server.test.js.map