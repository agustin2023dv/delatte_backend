import express, { RequestHandler, Request, Response, NextFunction, Application, Router } from 'express';
import { interfaces } from 'inversify';
import { OutgoingHttpHeaders } from 'node:http';
import { URL } from 'node:url';
import { Readable } from 'node:stream';

declare const TYPE: {
    AuthProvider: symbol;
    Controller: symbol;
    HttpContext: symbol;
};
declare const METADATA_KEY: {
    controller: string;
    controllerMethod: string;
    controllerParameter: string;
    httpContext: string;
    middleware: string;
};
declare enum PARAMETER_TYPE {
    REQUEST = 0,
    RESPONSE = 1,
    PARAMS = 2,
    QUERY = 3,
    BODY = 4,
    HEADERS = 5,
    COOKIES = 6,
    NEXT = 7,
    PRINCIPAL = 8
}
declare enum HTTP_VERBS_ENUM {
    all = "all",
    connect = "connect",
    delete = "delete",
    get = "get",
    head = "head",
    options = "options",
    patch = "patch",
    post = "post",
    propfind = "propfind",
    put = "put",
    trace = "trace"
}
declare const DUPLICATED_CONTROLLER_NAME: (name: string) => string;
declare const NO_CONTROLLERS_FOUND: string;
declare const DEFAULT_ROUTING_ROOT_PATH: string;

declare abstract class HttpContent {
    private readonly _headers;
    get headers(): OutgoingHttpHeaders;
    abstract readAsync(): Promise<unknown>;
}

declare class HttpResponseMessage {
    private _content;
    private _headers;
    private _statusCode;
    constructor(statusCode?: number);
    get content(): HttpContent;
    get headers(): OutgoingHttpHeaders;
    get statusCode(): number;
    set content(value: HttpContent);
    set headers(headers: OutgoingHttpHeaders);
    set statusCode(code: number);
}

type Prototype<T> = {
    [P in keyof T]: T[P] extends NewableFunction ? T[P] : T[P] | undefined;
} & {
    constructor: NewableFunction;
};
interface ConstructorFunction<T = Record<string, unknown>> {
    prototype: Prototype<T>;
    new (...args: unknown[]): T;
}
type DecoratorTarget<T = unknown> = ConstructorFunction<T> | Prototype<T>;
type Middleware = interfaces.ServiceIdentifier | RequestHandler;
interface MiddlewareMetaData {
    [identifier: string]: Middleware[];
}
type ControllerHandler = (...params: unknown[]) => unknown;
interface Controller {
}
interface ControllerMetadata {
    middleware: Middleware[];
    path: string;
    target: DecoratorTarget;
}
interface ControllerMethodMetadata extends ControllerMetadata {
    key: string;
    method: HTTP_VERBS_ENUM;
}
interface ControllerParameterMetadata {
    [methodName: string]: ParameterMetadata[];
}
interface ParameterMetadata {
    index: number;
    injectRoot: boolean;
    parameterName?: string | symbol | undefined;
    type: PARAMETER_TYPE;
}
type ExtractedParameters = ParameterMetadata[] | [Request, Response, NextFunction] | unknown[];
type HandlerDecorator = (target: DecoratorTarget, key: string, value: unknown) => void;
type ConfigFunction = (app: Application) => void;
interface RoutingConfig {
    rootPath: string;
}
interface Principal<T = unknown> {
    details: T;
    isAuthenticated(): Promise<boolean>;
    isInRole(role: string): Promise<boolean>;
    isResourceOwner(resourceId: unknown): Promise<boolean>;
}
interface AuthProvider {
    getUser(req: Request, res: Response, next: NextFunction): Promise<Principal>;
}
interface HttpContext<T = unknown> {
    container: interfaces.Container;
    request: Request;
    response: Response;
    user: Principal<T>;
}
interface IHttpActionResult {
    executeAsync(): Promise<HttpResponseMessage>;
}
interface RouteDetails {
    args?: string[];
    route: string;
}
interface RouteInfo {
    controller: string;
    endpoints: RouteDetails[];
}
interface RawMetadata {
    controllerMetadata: ControllerMetadata;
    methodMetadata: ControllerMethodMetadata[];
    parameterMetadata: ControllerParameterMetadata;
}

type interfaces_d_AuthProvider = AuthProvider;
type interfaces_d_ConfigFunction = ConfigFunction;
type interfaces_d_Controller = Controller;
type interfaces_d_ControllerHandler = ControllerHandler;
type interfaces_d_ControllerMetadata = ControllerMetadata;
type interfaces_d_ControllerMethodMetadata = ControllerMethodMetadata;
type interfaces_d_ControllerParameterMetadata = ControllerParameterMetadata;
type interfaces_d_DecoratorTarget<T = unknown> = DecoratorTarget<T>;
type interfaces_d_ExtractedParameters = ExtractedParameters;
type interfaces_d_HandlerDecorator = HandlerDecorator;
type interfaces_d_HttpContext<T = unknown> = HttpContext<T>;
type interfaces_d_IHttpActionResult = IHttpActionResult;
type interfaces_d_Middleware = Middleware;
type interfaces_d_MiddlewareMetaData = MiddlewareMetaData;
type interfaces_d_ParameterMetadata = ParameterMetadata;
type interfaces_d_Principal<T = unknown> = Principal<T>;
type interfaces_d_RawMetadata = RawMetadata;
type interfaces_d_RouteDetails = RouteDetails;
type interfaces_d_RouteInfo = RouteInfo;
type interfaces_d_RoutingConfig = RoutingConfig;
declare namespace interfaces_d {
  export type { interfaces_d_AuthProvider as AuthProvider, interfaces_d_ConfigFunction as ConfigFunction, interfaces_d_Controller as Controller, interfaces_d_ControllerHandler as ControllerHandler, interfaces_d_ControllerMetadata as ControllerMetadata, interfaces_d_ControllerMethodMetadata as ControllerMethodMetadata, interfaces_d_ControllerParameterMetadata as ControllerParameterMetadata, interfaces_d_DecoratorTarget as DecoratorTarget, interfaces_d_ExtractedParameters as ExtractedParameters, interfaces_d_HandlerDecorator as HandlerDecorator, interfaces_d_HttpContext as HttpContext, interfaces_d_IHttpActionResult as IHttpActionResult, interfaces_d_Middleware as Middleware, interfaces_d_MiddlewareMetaData as MiddlewareMetaData, interfaces_d_ParameterMetadata as ParameterMetadata, interfaces_d_Principal as Principal, interfaces_d_RawMetadata as RawMetadata, interfaces_d_RouteDetails as RouteDetails, interfaces_d_RouteInfo as RouteInfo, interfaces_d_RoutingConfig as RoutingConfig };
}

declare class InversifyExpressServer {
    private readonly _router;
    private readonly _container;
    private readonly _app;
    private _configFn;
    private _errorConfigFn;
    private readonly _routingConfig;
    private readonly _authProvider;
    private readonly _forceControllers;
    /**
     * Wrapper for the express server.
     *
     * @param container Container loaded with all controllers and their dependencies.
     * @param customRouter optional express.Router custom router
     * @param routingConfig optional interfaces.RoutingConfig routing config
     * @param customApp optional express.Application custom app
     * @param authProvider optional interfaces.AuthProvider auth provider
     * @param forceControllers optional boolean setting to force controllers (defaults do true)
     */
    constructor(container: interfaces.Container, customRouter?: Router | null, routingConfig?: RoutingConfig | null, customApp?: Application | null, authProvider?: (new () => AuthProvider) | null, forceControllers?: boolean);
    /**
     * Sets the configuration function to be applied to the application.
     * Note that the config function is not actually executed until a call to
     * InversifyExpresServer.build().
     *
     * This method is chainable.
     *
     * @param fn Function in which app-level middleware can be registered.
     */
    setConfig(fn: ConfigFunction): this;
    /**
     * Sets the error handler configuration function to be applied to the application.
     * Note that the error config function is not actually executed until a call to
     * InversifyExpresServer.build().
     *
     * This method is chainable.
     *
     * @param fn Function in which app-level error handlers can be registered.
     */
    setErrorConfig(fn: ConfigFunction): this;
    /**
     * Applies all routes and configuration to the server, returning the express application.
     */
    build(): express.Application;
    private registerControllers;
    private mergePaths;
    private resolveMiddlewere;
    private copyHeadersTo;
    private handleHttpResponseMessage;
    private handlerFactory;
    private _getHttpContext;
    private _createHttpContext;
    private _getCurrentUser;
    private extractParameters;
    private getParam;
    private _getPrincipal;
}

declare const injectHttpContext: <T = unknown>(target: DecoratorTarget, targetKey?: string | symbol, indexOrPropertyDescriptor?: number | TypedPropertyDescriptor<T>) => void;
declare function withMiddleware(...middleware: Middleware[]): (target: DecoratorTarget | NewableFunction, methodName?: string) => void;
declare function controller(path: string, ...middleware: Middleware[]): (target: NewableFunction) => void;
declare function all(path: string, ...middleware: Middleware[]): HandlerDecorator;
declare function httpGet(path: string, ...middleware: Middleware[]): HandlerDecorator;
declare function httpPost(path: string, ...middleware: Middleware[]): HandlerDecorator;
declare function httpPut(path: string, ...middleware: Middleware[]): HandlerDecorator;
declare function httpPatch(path: string, ...middleware: Middleware[]): HandlerDecorator;
declare function httpHead(path: string, ...middleware: Middleware[]): HandlerDecorator;
declare function httpDelete(path: string, ...middleware: Middleware[]): HandlerDecorator;
declare function httpOptions(path: string, ...middleware: Middleware[]): HandlerDecorator;
declare function httpMethod(method: HTTP_VERBS_ENUM, path: string, ...middleware: Middleware[]): HandlerDecorator;
declare const request: () => ParameterDecorator;
declare const response: () => ParameterDecorator;
declare const requestParam: (paramName?: string) => ParameterDecorator;
declare const queryParam: (queryParamName?: string) => ParameterDecorator;
declare const requestBody: () => ParameterDecorator;
declare const requestHeaders: (headerName?: string) => ParameterDecorator;
declare const cookies: (cookieName?: string) => ParameterDecorator;
declare const next: () => ParameterDecorator;
declare const principal: () => ParameterDecorator;
declare function params(type: PARAMETER_TYPE, parameterName?: string | symbol): (target: object, methodName: string | symbol | undefined, index: number) => void;

declare class BadRequestErrorMessageResult implements IHttpActionResult {
    private readonly message;
    constructor(message: string);
    executeAsync(): Promise<HttpResponseMessage>;
}

declare class BadRequestResult implements IHttpActionResult {
    executeAsync(): Promise<HttpResponseMessage>;
}

declare class ConflictResult implements IHttpActionResult {
    executeAsync(): Promise<HttpResponseMessage>;
}

declare class CreatedNegotiatedContentResult<T> implements IHttpActionResult {
    private readonly location;
    private readonly content;
    constructor(location: string | URL, content: T);
    executeAsync(): Promise<HttpResponseMessage>;
}

declare class ExceptionResult implements IHttpActionResult {
    private readonly error;
    constructor(error: Error);
    executeAsync(): Promise<HttpResponseMessage>;
}

declare class InternalServerErrorResult implements IHttpActionResult {
    executeAsync(): Promise<HttpResponseMessage>;
}

declare class JsonResult implements IHttpActionResult {
    readonly json: unknown;
    readonly statusCode: number;
    constructor(json: unknown, statusCode: number);
    executeAsync(): Promise<HttpResponseMessage>;
}

declare class NotFoundResult implements IHttpActionResult {
    executeAsync(): Promise<HttpResponseMessage>;
}

declare class OkNegotiatedContentResult<T> implements IHttpActionResult {
    private readonly content;
    constructor(content: T);
    executeAsync(): Promise<HttpResponseMessage>;
}

declare class OkResult implements IHttpActionResult {
    executeAsync(): Promise<HttpResponseMessage>;
}

declare class RedirectResult implements IHttpActionResult {
    private readonly location;
    constructor(location: string | URL);
    executeAsync(): Promise<HttpResponseMessage>;
}

declare class ResponseMessageResult implements IHttpActionResult {
    private readonly message;
    constructor(message: HttpResponseMessage);
    executeAsync(): Promise<HttpResponseMessage>;
}

declare class StatusCodeResult implements IHttpActionResult {
    private readonly statusCode;
    constructor(statusCode: number);
    executeAsync(): Promise<HttpResponseMessage>;
}

declare class StreamResult implements IHttpActionResult {
    readableStream: Readable;
    contentType: string;
    readonly statusCode: number;
    constructor(readableStream: Readable, contentType: string, statusCode: number);
    executeAsync(): Promise<HttpResponseMessage>;
}

//# sourceMappingURL=index.d.ts.map

type index_d_BadRequestErrorMessageResult = BadRequestErrorMessageResult;
declare const index_d_BadRequestErrorMessageResult: typeof BadRequestErrorMessageResult;
type index_d_BadRequestResult = BadRequestResult;
declare const index_d_BadRequestResult: typeof BadRequestResult;
type index_d_ConflictResult = ConflictResult;
declare const index_d_ConflictResult: typeof ConflictResult;
type index_d_CreatedNegotiatedContentResult<T> = CreatedNegotiatedContentResult<T>;
declare const index_d_CreatedNegotiatedContentResult: typeof CreatedNegotiatedContentResult;
type index_d_ExceptionResult = ExceptionResult;
declare const index_d_ExceptionResult: typeof ExceptionResult;
type index_d_InternalServerErrorResult = InternalServerErrorResult;
declare const index_d_InternalServerErrorResult: typeof InternalServerErrorResult;
type index_d_JsonResult = JsonResult;
declare const index_d_JsonResult: typeof JsonResult;
type index_d_NotFoundResult = NotFoundResult;
declare const index_d_NotFoundResult: typeof NotFoundResult;
type index_d_OkNegotiatedContentResult<T> = OkNegotiatedContentResult<T>;
declare const index_d_OkNegotiatedContentResult: typeof OkNegotiatedContentResult;
type index_d_OkResult = OkResult;
declare const index_d_OkResult: typeof OkResult;
type index_d_RedirectResult = RedirectResult;
declare const index_d_RedirectResult: typeof RedirectResult;
type index_d_ResponseMessageResult = ResponseMessageResult;
declare const index_d_ResponseMessageResult: typeof ResponseMessageResult;
type index_d_StatusCodeResult = StatusCodeResult;
declare const index_d_StatusCodeResult: typeof StatusCodeResult;
type index_d_StreamResult = StreamResult;
declare const index_d_StreamResult: typeof StreamResult;
declare namespace index_d {
  export { index_d_BadRequestErrorMessageResult as BadRequestErrorMessageResult, index_d_BadRequestResult as BadRequestResult, index_d_ConflictResult as ConflictResult, index_d_CreatedNegotiatedContentResult as CreatedNegotiatedContentResult, index_d_ExceptionResult as ExceptionResult, index_d_InternalServerErrorResult as InternalServerErrorResult, index_d_JsonResult as JsonResult, index_d_NotFoundResult as NotFoundResult, index_d_OkNegotiatedContentResult as OkNegotiatedContentResult, index_d_OkResult as OkResult, index_d_RedirectResult as RedirectResult, index_d_ResponseMessageResult as ResponseMessageResult, index_d_StatusCodeResult as StatusCodeResult, index_d_StreamResult as StreamResult };
}

declare class BaseHttpController {
    protected readonly httpContext: HttpContext;
    protected created<T>(location: string | URL, content: T): CreatedNegotiatedContentResult<T>;
    protected conflict(): ConflictResult;
    protected ok<T>(content: T): OkNegotiatedContentResult<T>;
    protected ok(): OkResult;
    protected badRequest(): BadRequestResult;
    protected badRequest(message: string): BadRequestErrorMessageResult;
    protected internalServerError(): InternalServerErrorResult;
    protected internalServerError(error: Error): ExceptionResult;
    protected notFound(): NotFoundResult;
    protected redirect(uri: string | URL): RedirectResult;
    protected responseMessage(message: HttpResponseMessage): ResponseMessageResult;
    protected statusCode(statusCode: number): StatusCodeResult;
    protected json(content: unknown, statusCode?: number): JsonResult;
    protected stream(readableStream: Readable, contentType: string, statusCode?: number): StreamResult;
}

declare abstract class BaseMiddleware implements BaseMiddleware {
    httpContext: HttpContext;
    protected bind<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): interfaces.BindingToSyntax<T>;
    abstract handler(req: Request, res: Response, next: NextFunction): void | Promise<void>;
}

declare function getControllersFromContainer(container: interfaces.Container, forceControllers: boolean): Controller[];
declare function getControllersFromMetadata(): DecoratorTarget[];
declare function getMiddlewareMetadata(constructor: DecoratorTarget, key: string): Middleware[];
declare function getControllerMetadata(constructor: NewableFunction): ControllerMetadata;
declare function getControllerMethodMetadata(constructor: NewableFunction): ControllerMethodMetadata[];
declare function getControllerParameterMetadata(constructor: NewableFunction): ControllerParameterMetadata;
declare function cleanUpMetadata(): void;
declare function instanceOfIhttpActionResult(value: unknown): value is IHttpActionResult;
declare function getOrCreateMetadata<T>(key: string, target: object, defaultValue: T): T;

declare function getRouteInfo(container: interfaces.Container): RouteInfo[];
declare function getRawMetadata(container: interfaces.Container): RawMetadata[];

declare class StringContent extends HttpContent {
    private readonly content;
    constructor(content: string);
    readAsync(): Promise<string>;
}

declare class JsonContent extends HttpContent {
    private readonly content;
    constructor(content: unknown);
    readAsync(): Promise<unknown>;
}

export { type AuthProvider, BaseHttpController, BaseMiddleware, type ConfigFunction, type Controller, type ControllerHandler, type ControllerMetadata, type ControllerMethodMetadata, type ControllerParameterMetadata, DEFAULT_ROUTING_ROOT_PATH, DUPLICATED_CONTROLLER_NAME, type DecoratorTarget, type ExtractedParameters, HTTP_VERBS_ENUM, type HandlerDecorator, HttpContent, type HttpContext, HttpResponseMessage, type IHttpActionResult, InversifyExpressServer, JsonContent, METADATA_KEY, type Middleware, type MiddlewareMetaData, NO_CONTROLLERS_FOUND, PARAMETER_TYPE, type ParameterMetadata, type Principal, type RawMetadata, type RouteDetails, type RouteInfo, type RoutingConfig, StringContent, TYPE, all, cleanUpMetadata, controller, cookies, getControllerMetadata, getControllerMethodMetadata, getControllerParameterMetadata, getControllersFromContainer, getControllersFromMetadata, getMiddlewareMetadata, getOrCreateMetadata, getRawMetadata, getRouteInfo, httpDelete, httpGet, httpHead, httpMethod, httpOptions, httpPatch, httpPost, httpPut, injectHttpContext, instanceOfIhttpActionResult, interfaces_d as interfaces, next, params, principal, queryParam, request, requestBody, requestHeaders, requestParam, response, index_d as results, withMiddleware };
